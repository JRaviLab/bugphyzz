---
title: "Check Functions"
output: 
  rmarkdown::html_vignette:
    toc: yes
vignette: >
  %\VignetteIndexEntry{Check Functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
suppressMessages({
  library(bugphyzz)
  library(magrittr)
  library(dplyr)
  library(purrr)
})

```

This vignette describes how to run some checks on data frames imported from
bugphyzz using the check functions included in the package. The check functions
can be accessed using the triple colon `:::` operator and help can be accessed
using the `?` operator; for example, `?bugphyzz:::.checkRequiredColumnsDF`.

Currently, there are two sets of checks:

1. Check that all *mandatory columns* are present and in the right order in a
*single* data frame imported by bugphyzz. The function that performs this check
is `.checkRequiredColumnsDF`. The package includes a wrapper function to apply
`checkRequiredColumnsDF` to a *list* of bugphyzz data frames:
`checkRequiredColumnsList`.

2. Check that the *syntax* or *values* of a *single* column are valid in a
*single* data frame imported from bugphyzz. The function that performs this
check is `checkColumnValues`. There is a wrapper function to apply
`checkColumnValues` to all the columns of a *single* data frame:
`checkColumnValuesDF`. In turn, there is a wrapper function to apply
`checkColumnValuesDF` across a *list* of data frames imported from bugphyzz:
`checkColumnValuesList`.

Below, a more detailed explanation of the checks with some examples using
"toy data". Then, the functions are applied to generate reports of possible
errors across bugphyzz datasets.

# Explanation of the check functions

## Check required columns

Not all of the data frames imported with the bugphyzz functions
(`physiologies`, `fattyAcidComposition`) have the same columns. However,
there are some mandatory columns, referred to as "required columns" in the
package, that must be present in all datasets. These required columns,
currently nine, can be accessed with the `.requiredColumns` function:

```{r}
bugphyzz:::.requiredColumns()
```

The `checkRequiredColumnsDF` function checks: 
1) that all of the columns are present in a single data frame, and 
2) that all of the columns are in the correct order in that data frame.
If any of those conditions is not met, the function will print an error message
on screen indicating which columns are missing or misplaced.
If no errors are found, the function returns a message indicting that all of
the required columns are present and in the right order.
Furthermore, the `checkRequiredColumnsDF` function invisibly returns an error
condition object, which can be checked later.

Examples with toy data:

```{r}

list_of_datasets <- list(
  # a dataset with missing required columns (only two are present)
  dataset_with_missing_required_columns = data.frame(
    NCBI_ID = 1:10,
    Attribute = letters[1:10]),
  # a dataset with misplaced required columns
  dataset_with_misplaced_required_columns = data.frame(
    NCBI_ID = 1:10,
    Taxon_name = letters[1:10],
    Genome_ID = 1:10,
    Accession_ID = 1:10,
    Attribute = 1:10,
    Attribute_value = 1:10,
    Attribute_source = 1:10,
    Evidence = 1:10,
    Note = 1:10,
    Confidence_interval = 1:10),
  # a dataset with all columns in the right order
  dataset_with_required_columns_ok = data.frame(
    NCBI_ID = 1:10,
    Genome_ID = 1:10,
    Accession_ID = 1:10,
    Taxon_name = letters[1:10],
    Attribute = 1:10,
    Attribute_value = 1:10,
    Attribute_source = 1:10,
    Evidence = 1:10,
    Confidence_interval = 1:10,
    Note = 1:10)
  )
```

+ Case 1: Several "required columns" are missing from a data frame:

```{r}
err1 <- tryCatch(
    error = function(e) e,
    bugphyzz:::.checkRequiredColumnsDF(list_of_datasets[[1]], "missing_columns")
)    
err1
```

+ Case 2: A few of the required columns are not in the right order:

```{r}
err2 <- tryCatch(
    error = function(e) {
      conditionMessage(e)
      e
    },
    bugphyzz:::.checkRequiredColumnsDF(
        list_of_datasets[[2]], "misplaced_columns"
    )
)
  
err2$misplaced_cols
```

+ Case 3: All required columns are present and in the right order.

```{r}
no_err <- bugphyzz:::.checkRequiredColumnsDF(
    list_of_datasets[[3]], "required_columns_ok"
)
no_err
```

+ It's more convenient to apply this check to a list of data frames with
`checkRequiredColumnsList`, which also handles the error conditions:

```{r}
err3 <- bugphyzz:::.checkRequiredColumnsDFList(list_of_datasets)
err3
```


## Check syntax/validity of values

Valid syntax/values are determined according to the
[template.tsv file](https://github.com/waldronlab/bugphyzz/blob/main/inst/extdata/template.tsv),
which is installed with bugphyzz:

```{r}
template.tsv <- system.file("extdata/template.tsv", package = "bugphyzz")
template <- read.table(template.tsv, header = TRUE, sep = "\t")
template[,c("column_name", "valid_values", "test")]
```

The syntax/validity check is performed by the `checkColumnValues` function.
This function implements `grepl` searches of the values in the "valid_values"
column of the template file against the different columns of a data frame
imported from bugphyzz (as specified by the "column_name"
column of the template file). For example, the "NCBI_ID" column in a data
frame imported from bugphyzz should only contain integer values (`^[0-9]+$`).

In the case of the "Attribute" column (in a data frame imported from bugphyzz),
the regex used by `checkColumnValues` is generated with the helper function
`.attributes`, which prints the unique attribute values found in the
[attributes.tsv](https://github.com/waldronlab/bugphyzz/blob/main/inst/extdata/attributes.tsv)
file. This difference in behavior is indicated in the column "test" of the
template file.

In the case of the "Attribute_value" column (in a data frame imported from
bugphyzz), the `checkColumnValues` function checks the class instead of values
(as indicated in the "test column of the template file).

Toy data:

```{r}
# a list with only one data frame
list_of_df <- list(dataset_with_bad_values = data.frame(
    NCBI_ID = letters[1:10],
    Genome_ID = 1:10,
    Accession_ID = 1:10,
    Taxon_name = letters[1:10],
    Attribute = 1:10,
    Attribute_value = letters[1:10],
    Attribute_source = 1:10,
    Evidence = 1:10,
    Confidence_interval = 1:10,
    Note = 1:10
  )
)
```

+ Case 1: Check the values in the NCBI_ID column of a single data frame:

```{r}
err4 <- tryCatch(
    error = function(e) {
      conditionMessage(e)
      e
    },
    bugphyzz:::.checkColumnValues("NCBI_ID", list_of_df[[1]])
)
  
err4
```

In the example above, the invalid values (and other metadata) can be obtained
from the error condition object (`err4`) with the `$` operator:

```{r}
# Print invalid values
err4$invalid_values

# Print row with invalid values
err4$invalid_pos
```

+ Case 2: Check the values of all of the columns of a single data frame with
the `checkColumnValuesDF` function.

```{r}
err5 <- tryCatch(
    error = function(e) {
      conditionMessage(e)
      e
    },
    bugphyzz:::.checkColumnValuesDF(
        list_of_df[[1]], "dataset_with_invalid_column"
    )
)
err5
```

In the case above, the output is a list of error conditions. 
Metadata can be accessed with the `$` operator.

```{r}
# accessing invalid values
err5$NCBI_ID$invalid_values
```


+ Case 3: Check the values of all of the columns of all of the data frames
contained in a list with the `checkColumnValuesList` function.

```{r}
err6 <- bugphyzz:::.checkColumnValuesList(list_of_df)
err6
```
The output (if any errors are found) is a nested list of error conditions and
metadata can be accessed in the same way as in the examples above with the
`$` operator:

```{r}
# access invalid values
err6$dataset_with_bad_values$NCBI_ID$invalid_values
```


# Report of syntax/validity errors in datasets imported by bugphyzz

## Datasets imported with the `physiologies` function

Import bugphyzz data:

```{r}
bp <- physiologies()
# bp <- physiologies(keyword = c("aerophilicity", "plant pathogenicity"))
```
Generate list of errors:

```{r}
list_of_errors <- bugphyzz:::.checkColumnValuesList(bp)
```

Turn list of errors into a table with links:


```{r, echo=FALSE}
# A function to recover metadata from the error output
errorMetadata <- function(x) {
  
  output <- list(
  type_of_error = class(x)[1],
  number_invalid_values = length(x$invalid_values),
  invalid_values = paste0(head(x$invalid_values), collapse = "; ")
  )
  
  if (output$number_invalid_values == 0) {
    output$number_invalid_values <- NA
    output$invalid_values <- NA
  }
  
  return(output)
}

# Create and error table displaying dataset, column, and metadata (one line per error)
error_table <-  purrr::modify_depth(list_of_errors, 2, ~ errorMetadata(.x)) %>% 
  purrr::modify_depth(1, ~ bind_rows(.x, .id = "column")) %>% 
  bind_rows(.id = "dataset")

# Dataset simensions
dataset_dimensions <- map_chr(bp, ~ paste0(dim(.x), collapse = " x ")) %>% 
  as_tibble(rownames = "dataset") %>% 
  magrittr::set_colnames(c("dataset", "dataset_dimensions"))


# Import google links
fname <- system.file("extdata/links.tsv", package = "bugphyzz")
data_links <- readr::read_tsv(fname, col_types = "ccc") %>% 
  select(physiology, link)

# Join tables together
error_table <- left_join(error_table, dataset_dimensions, by = "dataset") %>% 
  left_join(data_links, by  = c("dataset" = "physiology")) %>% 
  mutate(n_error = row_number()) %>% 
  relocate(n_error)

knitr::kable(error_table)


```

## Dataset imported with the `fattyAcidComposition` function


```{r}
fac <- fattyAcidComposition()
```

```{r}
fac_errors <-  bugphyzz:::.checkColumnValuesDF(fac)
```

```{r, echo=FALSE}

# Create and error table displaying dataset, column, and metadata (one line per error)
error_table <-  purrr::modify_depth(fac_errors, 1, ~ errorMetadata(.x)) %>% 
  bind_rows(.id = "dataset")

# Dataset simensions
fac_dimensions <- paste0(dim(fac), collapse = " x ")


# Import google links
customlinks.tsv <- system.file("extdata/customlinks.tsv", package = "bugphyzz")
fac_link <- readr::read_tsv(customlinks.tsv, col_types = "cccc") %>% 
  filter(physiology == "fatty acid composition") %>% 
  pull(var = link)

# Join tables together
error_table <- error_table %>% 
  mutate(n_error = row_number(), dataset_dimensions = fac_dimensions, link = fac_link) %>% 
  relocate(n_error)

knitr::kable(error_table)
```
# Check required columns


## Check required columns in the "physiologies" datasets.

```{r}
errors <- bugphyzz:::.checkRequiredColumnsDFList(bp)

if (!length(errors)) {
    no_errors_message = "All required columns are present and in the right column across the list of bugphyzz datasets imported with the `physiologies` function."
    as.data.frame(no_errors_message) %>% 
      knitr::kable()
}

```

## check required columns in the fatty acid composition dataset:

```{r}
fac_required_columns_errors <- tryCatch(
    error = function(e) {
      conditionMessage(e)
      e
    },
    bugphyzz:::.checkRequiredColumnsDF(fac)
)

as.data.frame(fac_required_columns_errors$message) %>% 
  knitr::kable()

```

